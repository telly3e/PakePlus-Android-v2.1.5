<!DOCTYPE html>
<html lang="en">
<head>
    
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="../favicon.ico">
    
        <link href="../assets/styles.css" rel="stylesheet">
    
        <link href="../assets/scripts.css" rel="stylesheet">
    
    
        <script type="module" src="../assets/scripts.js"></script>
    
    
    
    
    <title>笔记 - King&#39;s College London</title>
    <script>
        // Load dark/light theme as soon as possible to avoid color flashes.
        let theme = localStorage.getItem("theme");
        if (!theme) {
            theme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? "dark" : "light";
        }
        document.documentElement.classList.add(`theme-${theme}`);

        window.glob = {
            isStatic: true,
            theme
        };
    </script>
    <!-- HTML Meta Tags -->
    <meta name="description" content="">
    <!-- Facebook Meta Tags -->
    <meta property="og:url" content="">
    <meta property="og:type" content="website">
    <meta property="og:title" content="笔记 - King&#39;s College London">
    <meta property="og:description" content="">
    <meta property="og:image" content="">
    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="">
    <meta property="twitter:url" content="">
    <meta name="twitter:title" content="笔记 - King&#39;s College London">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="">
    <!-- Meta Tags Generated via https://opengraph.dev -->
    <meta name="theme-color" content="">
    
</head>

<body data-note-id="ngt1KsPq5da9" class="type-text" data-ancestor-note-id="2Q5IsQ2Y5GfB">

<div id="mobile-header">
    <a href="../">
            <img src="../icon-color.svg" width="32" height="24.150943396226417" alt="Logo" />
        King&#39;s College London
    </a>
    <button aria-label="Show Mobile Menu" id="show-menu-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path></svg></button>
</div>
<div id="split-pane">
    <div id="left-pane">
        <div id="navigation">
            <div id="site-header">
                <a href="../">
                    <img src="../icon-color.svg" width="53" height="40" alt="Logo" />
                    King&#39;s College London
                </a>
                <div class="theme-selection">
                    <span id="sitetheme">网站主题</span>
                    <label class="switch">
                      <input type="checkbox" aria-labelledby="sitetheme">
                      <span class="slider"></span>
                      <svg class="dark-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M20.742 13.045a8.088 8.088 0 0 1-2.077.271c-2.135 0-4.14-.83-5.646-2.336a8.025 8.025 0 0 1-2.064-7.723A1 1 0 0 0 9.73 2.034a10.014 10.014 0 0 0-4.489 2.582c-3.898 3.898-3.898 10.243 0 14.143a9.937 9.937 0 0 0 7.072 2.93 9.93 9.93 0 0 0 7.07-2.929 10.007 10.007 0 0 0 2.583-4.491 1.001 1.001 0 0 0-1.224-1.224zm-2.772 4.301a7.947 7.947 0 0 1-5.656 2.343 7.953 7.953 0 0 1-5.658-2.344c-3.118-3.119-3.118-8.195 0-11.314a7.923 7.923 0 0 1 2.06-1.483 10.027 10.027 0 0 0 2.89 7.848 9.972 9.972 0 0 0 7.848 2.891 8.036 8.036 0 0 1-1.484 2.059z"></path></svg>
                      <svg class="light-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6.993 12c0 2.761 2.246 5.007 5.007 5.007s5.007-2.246 5.007-5.007S14.761 6.993 12 6.993 6.993 9.239 6.993 12zM12 8.993c1.658 0 3.007 1.349 3.007 3.007S13.658 15.007 12 15.007 8.993 13.658 8.993 12 10.342 8.993 12 8.993zM10.998 19h2v3h-2zm0-17h2v3h-2zm-9 9h3v2h-3zm17 0h3v2h-3zM4.219 18.363l2.12-2.122 1.415 1.414-2.12 2.122zM16.24 6.344l2.122-2.122 1.414 1.414-2.122 2.122zM6.342 7.759 4.22 5.637l1.415-1.414 2.12 2.122zm13.434 10.605-1.414 1.414-2.122-2.122 1.414-1.414z"></path></svg>
                    </label>
                    <script>
                        const el = document.querySelector(".theme-selection input");
                        el.checked = (glob.theme === "dark");
                    </script>
                </div>
                
                    <div class="search-item">
                        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M10 18a7.952 7.952 0 0 0 4.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z"></path></svg>
                        <input type="text" class="search-input" placeholder="搜索...">
                    </div>
                
            </div>
        
            <nav id="menu">
                

    



<ul>
    
    
        <li class="submenu-item expanded">
            

    
    <a class="type-text" href="../7CCEMEMB%20Embedded%20System%20Desig.html">
        <button class="collapse-button" aria-label="展开"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></button>
        <span><i class="bx bx-folder"></i> 7CCEMEMB Embedded System Design</span>
    </a>




<ul>
    
    
        <li class="item expanded">
            

    
    <a class="type-text active" href="%E7%AC%94%E8%AE%B0.html">
        
        <span><i class="bx bx-note"></i> 笔记</span>
    </a>





        </li>
    
</ul>


        </li>
    
    
        <li class="submenu-item">
            

    
    <a class="type-text" href="../7CCEMTN1%20Telecommunications%20Ne.html">
        <button class="collapse-button" aria-label="展开"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></button>
        <span><i class="bx bx-folder"></i> 7CCEMTN1 Telecommunications Networks I</span>
    </a>




<ul>
    
    
        <li class="item">
            

    
    <a class="type-text" href="../7CCEMTN1%20Telecommunications%20Networks%20I/%E7%AC%94%E8%AE%B0.html">
        
        <span><i class="bx bx-note"></i> 笔记</span>
    </a>





        </li>
    
    
        <li class="item">
            

    
    <a class="type-text" href="../7CCEMTN1%20Telecommunications%20Networks%20I/2025%20Mock%20Paper.html">
        
        <span><i class="bx bx-note"></i> 2025 Mock Paper</span>
    </a>





        </li>
    
    
        <li class="item">
            

    
    <a class="type-text" href="../7CCEMTN1%20Telecommunications%20Networks%20I/Example%20questions.html">
        
        <span><i class="bx bx-note"></i> Example questions</span>
    </a>





        </li>
    
</ul>


        </li>
    
</ul>


            </nav>
           
        </div>
    </div>
    <div id="right-pane">
        <div id="main">
            <div id="content" class="type-text ck-content">
                
                    <h1 id="title">笔记</h1>
                
                    
                    <h2>7CCEMEMB Embedded System Design<a id="7ccememb-embedded-system-design" class="toc-anchor" name="7ccememb-embedded-system-design" href="#7ccememb-embedded-system-design">#</a></h2><h2>I. Introduction<a id="i-introduction" class="toc-anchor" name="i-introduction" href="#i-introduction">#</a></h2><p>Embedded systems are a combination of computer hardware and software designed for a specific function.</p><h3>Types of different embedded systems:<a id="types-of-different-embedded-systems" class="toc-anchor" name="types-of-different-embedded-systems" href="#types-of-different-embedded-systems">#</a></h3><ul><li data-list-item-id="e569266c75103717165e90a7b1b5ab8d9">Microcontroller</li><li data-list-item-id="efe1b9d6e80bba5861c3f50ca9e426f74">Microprocessor</li><li data-list-item-id="ed584f2236d6e3f177d8b9f9c7b955afb">System on a chip (SoCs)</li><li data-list-item-id="ea851da936f1da678ed00a1cdcd756f91">Field Programmable Gate Arrays (FPGA)</li></ul><h3>Challenges in embedded system design:<a id="challenges-in-embedded-system-design" class="toc-anchor" name="challenges-in-embedded-system-design" href="#challenges-in-embedded-system-design">#</a></h3><ul><li data-list-item-id="e4cefd186cfda71df15427cc60acad6a5">Sophisticated(精密的) functionality</li><li data-list-item-id="e1c3394da222ea94c8d27928b98c59c96">Real-time operation</li><li data-list-item-id="ef048151ff4098d67eea653d4e053e75f">Low manufacturing cost</li><li data-list-item-id="e9b86b64e4d5aae56df03ab021aff08a3">Low power consumption</li><li data-list-item-id="edafbe5473a4b4b80bc96053e666c4d9c">Often have to run sophisticated algorithms on multiple platforms</li><li data-list-item-id="e38486a39b55cae7534f9f2e7b1c59fe1">Often provide sophisticated user interfaces</li></ul><h3>Real-time embedded systems:<a id="real-time-embedded-systems" class="toc-anchor" name="real-time-embedded-systems" href="#real-time-embedded-systems">#</a></h3><p>correctness of the system behaviour not only depends</p><ul><li data-list-item-id="e999315593da3eafca796859a37c2e587">on the logical results of the computations</li><li data-list-item-id="e5cee3ea4e7c0aab18420e70dbb82d27b">on the time at which the result are produced</li></ul><h4>Hard Real-Time systems<a id="hard-real-time-systems" class="toc-anchor" name="hard-real-time-systems" href="#hard-real-time-systems">#</a></h4><ul><li data-list-item-id="effdc30ece3ad7b4ecad1a086035b6f83">Must always meet deadlines (critical task)</li><li data-list-item-id="ef6e9dfc667a607f61324b9ffc7bd8573">System fails if deadline window is missed. Example: airplane sensor, autopilot systems and spacecrafts.</li></ul><h4>Soft Real-Time system:<a id="soft-real-time-system" class="toc-anchor" name="soft-real-time-system" href="#soft-real-time-system">#</a></h4><ul><li data-list-item-id="eeb64658c4c4ad8a17e0bcc6f884aceef">Must try to meet deadlines (desirable task)</li><li data-list-item-id="e39f4d50e10877ab924ce78880fe29ecf">The system does not fail if few deadlines are missed.</li><li data-list-item-id="ef0adac4a5e271940f01f04b8cb669eac">Example, audio and video streams</li></ul><h3>Power Management<a id="power-management" class="toc-anchor" name="power-management" href="#power-management">#</a></h3><p>Modern microprocessors can control power consumption by</p><ul><li data-list-item-id="ea1a153ce59a65a9966bed188c5b64b07"><code spellcheck="false">disabling unused circuits</code> and</li><li data-list-item-id="e50f2da46d4fdcd503f69ae57c399221a"><code spellcheck="false">dynamically trimming clock speeds</code></li></ul><p>Software techniques:</p><ul><li data-list-item-id="e87291e8c9092d23d98658fd9b82bf74d">Dynamic voltage and frequency scaling (DVFS) to match system power consumption with required performance.</li></ul><h3>Embedded Systems Design Methodologies<a id="embedded-systems-design-methodologies" class="toc-anchor" name="embedded-systems-design-methodologies" href="#embedded-systems-design-methodologies">#</a></h3><ul><li data-list-item-id="eae9237529b7ae3b8ab896a28f51e7c7a">Top-down design: (start from most abstract description; work to most detailed)</li><li data-list-item-id="e264563541891b79d92ed79a065723098">Bottom-up design: (work from small components to big system)</li></ul><h4>Requirements Form / Sheet<a id="requirements-form-sheet" class="toc-anchor" name="requirements-form-sheet" href="#requirements-form-sheet">#</a></h4><figure class="table"><table><thead><tr><th>Items</th><th>Description</th></tr></thead><tbody><tr><td>Name</td><td>&nbsp;</td></tr><tr><td>Purpose</td><td>&nbsp;</td></tr><tr><td>Inputs</td><td>&nbsp;</td></tr><tr><td>Outputs</td><td>&nbsp;</td></tr><tr><td>Functions</td><td>&nbsp;</td></tr><tr><td>Performance</td><td>&nbsp;</td></tr><tr><td>Manufacture Costs</td><td>&nbsp;</td></tr><tr><td>Physical Size/weight</td><td>&nbsp;</td></tr><tr><td>Power</td><td>&nbsp;</td></tr></tbody></table></figure><p>Examples:</p><figure class="table"><table><thead><tr><th>Items</th><th>Description</th></tr></thead><tbody><tr><td>Name</td><td>GPS moving map</td></tr><tr><td>Purpose</td><td>Consumer-grade moving map for driving use</td></tr><tr><td>Inputs</td><td>Power button, two control buttons</td></tr><tr><td>Outputs</td><td>Back-lit LCD 400×600</td></tr><tr><td>Functions</td><td>Uses 5-receiver GPS system; three user-selectable resolutions; always displays current latitude and longitude</td></tr><tr><td>Performance</td><td>Updates screen within 0.25 seconds upon movement</td></tr><tr><td>Manufacture Costs</td><td>£40</td></tr><tr><td>Physical Size/weight</td><td>No more than 2×6 inches, 340g</td></tr><tr><td>Power</td><td>100mW</td></tr></tbody></table></figure><h3>Requirement<a id="requirement" class="toc-anchor" name="requirement" href="#requirement">#</a></h3><p>Informal description of what customer needs using plain language. It could be developed via interviewing customers, talking to marketing representatives, or getting feedback from customers. Requirements phase links customers with designers</p><h3>Specification<a id="specification" class="toc-anchor" name="specification" href="#specification">#</a></h3><p>Precise description of what design team should deliver.</p><p>The requirements may be functional and non-functional.</p><ul><li data-list-item-id="e9f8c56aa1288c0e6c93fe5ab73f90bbb">Non-functional<ul><li data-list-item-id="ede6e3db099800c92f0971f51223d903e">time required to compute output</li><li data-list-item-id="efe042cfe01e63b8c22c8c9217de6e799">power consumption</li><li data-list-item-id="ef1c7233fbad433808b2cf157b3623adf">manufacturing cost</li><li data-list-item-id="eba2714062d6e97dcf7e1abc9976f8a62">physical size, weight</li><li data-list-item-id="e4a10efb8bc39029497974d9ce4c573f5">time-to-market</li><li data-list-item-id="ecff404ab629c199a56eb0af0f18edc84">reliability</li></ul></li><li data-list-item-id="eb7e8c614fb3c4cce6d13654f7ba0c7f9">Functional<ul><li data-list-item-id="e5dcd3db2ef6e2a4825f594482d234318">input/output relationships</li></ul></li></ul><p>Many specification styles:</p><ul><li data-list-item-id="ea3b3705d5df99af14f0b966eca1bc2cb">Control-oriented vs. Data-oriented;</li><li data-list-item-id="e2be61fc8c9cf519d62a351f26aefc4ff">Textual vs. Graphical.</li></ul><h3>Harvard vs Von Neumann Architecture<a id="harvard-vs-von-neumann-architecture" class="toc-anchor" name="harvard-vs-von-neumann-architecture" href="#harvard-vs-von-neumann-architecture">#</a></h3><ul><li data-list-item-id="e66a9c731e0e60ea358044d3dac50f429">Harvard architecture has a separate program memory and data memory, which are accessed from separate buses.</li><li data-list-item-id="e1a48720cc6899c837493cb0f86ebd156">This improves bandwidth over traditional von Neumann architecture, in which program and data are fetched from the same memory using the same bus.&nbsp;</li></ul><figure class="image" style="height:auto;"><img alt="文章图片" loading="lazy" style="aspect-ratio:778/292;" src="笔记_image.png" width="778" height="292"></figure><h2>II. Embedded System Architecture<a id="ii-embedded-system-architecture" class="toc-anchor" name="ii-embedded-system-architecture" href="#ii-embedded-system-architecture">#</a></h2><h3>Computer<a id="computer" class="toc-anchor" name="computer" href="#computer">#</a></h3><p>A calculating machine that can</p><ul><li data-list-item-id="e2d62fe71776760d2819eb2b01d002f61">Accepts input information.</li><li data-list-item-id="e494bb1af5b2e7c11480d63f17833c65b">Processes the information according to a list of internally stored instructions</li><li data-list-item-id="e81bff39492139a26ad7a8425ca70c57a">Produces the resulting output information.</li></ul><h3>Microprocessor<a id="microprocessor" class="toc-anchor" name="microprocessor" href="#microprocessor">#</a></h3><p>It consists of only a central processing unit and uses an external bus to interface to RAM, ROM, and other peripherals. (e.g. CPU of a computer ...)</p><ul><li data-list-item-id="e3c8f4893fa6be252011ffffd376effa5">higher processing speed</li></ul><h3>Microcontroller<a id="microcontroller" class="toc-anchor" name="microcontroller" href="#microcontroller">#</a></h3><p><img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image-1.png" width="385" height="211"></p><ul><li data-list-item-id="e803cc760e554c7b191d639590917ac25">more cost-effective</li><li data-list-item-id="e50f03c5d913c1de1d42ce62351d28051">more efficient power saving (e.g. the control board of a washing machine / microwave oven ...)</li></ul><h3>Functional Units of a computer<a id="functional-units-of-a-computer" class="toc-anchor" name="functional-units-of-a-computer" href="#functional-units-of-a-computer">#</a></h3><ul><li data-list-item-id="e7628a265b79dfa52fb34588d915c7e70">Input<ul><li data-list-item-id="e7059e594cbf9f12f83b5ef14ef3a0499">Keyboard ...</li></ul></li><li data-list-item-id="e40048f1c2905e22a58cf2f4e1b4b337c">Output<ul><li data-list-item-id="e3677bda17efda7e0ad7efa0da71d3ca4">monitor ...</li><li data-list-item-id="e8f26bd3bdb181598a729ea207c55374c">printer ...</li></ul></li><li data-list-item-id="e99778eafba4d5e192e135b094b70eb4a">ALU<ul><li data-list-item-id="e20412ab4c55fa3d64999143853b693ba">perform the desired operations on input info by instructions in the mem.</li></ul></li><li data-list-item-id="ea900f3df6b59b196f8e73c7d9e915ab8">Control (coordinates various action)<ul><li data-list-item-id="e796c2abdd1ed9373bae81207f5ab9a4e">input</li><li data-list-item-id="e6006af859f412c30034483030e109f0b">output</li><li data-list-item-id="e80c9dca82b62935509a7c8b83049e81f">processing</li></ul></li><li data-list-item-id="e7933d051b0c70b1427e79bc6af56d553">Memory (stores information)<ul><li data-list-item-id="e07535c1ac66279dce9724fa1cd8d0d02">instructions</li><li data-list-item-id="e1f8bdf3dcc683b27027f3b9ee311a391">data</li></ul></li></ul><h3>How are the functional units are connected?<a id="how-are-the-functional-units-are-connected" class="toc-anchor" name="how-are-the-functional-units-are-connected" href="#how-are-the-functional-units-are-connected">#</a></h3><p>They may be connected by <code spellcheck="false">a group of parallel wires</code> which is called a <code spellcheck="false">bus</code>. <img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251226_212032.png" width="578" height="172"></p><h4>Organisation of Cache and main memory<a id="organisation-of-cache-and-main-memory" class="toc-anchor" name="organisation-of-cache-and-main-memory" href="#organisation-of-cache-and-main-memory">#</a></h4><p><img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251226_211353.png" width="582" height="288"></p><h3>Arithmetic Logic Units<a id="arithmetic-logic-units" class="toc-anchor" name="arithmetic-logic-units" href="#arithmetic-logic-units">#</a></h3><p>ALU has two units:</p><ul><li data-list-item-id="e71c07aca83306930b8fce211caca862e">Arithmetic Units perform all <code spellcheck="false">arithmetic operations</code> in a computer, and simple things like add one to a number.</li><li data-list-item-id="e47f8042a0cff8f17e973cf574bd6d0e4">Logic Units perform the <code spellcheck="false">logical operations</code> and simple numerical tests such as negative or positive.</li></ul><h3>Half Adder and Full Adder<a id="half-adder-and-full-adder" class="toc-anchor" name="half-adder-and-full-adder" href="#half-adder-and-full-adder">#</a></h3><p>Computers use binary for addition. Addition has two outputs: <strong>Sum (Sum)</strong> and <strong>Carry (Carry)</strong>.</p><h4>Half Adder<a id="half-adder" class="toc-anchor" name="half-adder" href="#half-adder">#</a></h4><ul><li data-list-item-id="e922708163a6c8a837533bf199b93284e">can only handle the addition of two 1-bit binary numbers (A and B).</li><li data-list-item-id="ec7bfe6e254b249d6351e9a0dd2a169cb">Cannot handle the carry-in bit.</li><li data-list-item-id="e0d79d72c6e669787139976206e7fa38b">Output:&nbsp;<span class="math-tex">\(Sum = A \oplus B\)</span>&nbsp;(different or),&nbsp;<span class="math-tex">\(Carry = A \cdot B\)</span>&nbsp;(and).</li></ul><h4>Full Adder<a id="full-adder" class="toc-anchor" name="full-adder" href="#full-adder">#</a></h4><ul><li data-list-item-id="e5f9f9b7470f2a5f036fd2cca7ee87b05">Can handle three inputs: two additions A, B, and the previous carry-in bit (<span class="math-tex">\(C_{in}\)</span>).</li></ul><h4>Differences<a id="differences" class="toc-anchor" name="differences" href="#differences">#</a></h4><p>A full adder can be "cascaded" to form a multi-bit adder (e.g., 8-bit or 64-bit addition), whereas a half adder is usually used for lowest-bit calculations only.</p><h3>How Control Unit works?<a id="how-control-unit-works" class="toc-anchor" name="how-control-unit-works" href="#how-control-unit-works">#</a></h3><ul><li data-list-item-id="e356cb3c02731322aa99e692a5635836b"><code spellcheck="false">Fetch</code>: Reads the address of the next instruction to be executed from memory.</li><li data-list-item-id="ed616c25f5ef98d410893d431f454908a"><code spellcheck="false">Decode</code>: Converts an instruction into an electronic control signal that determines what operation is to be performed (addition, jump, move data, etc.).</li><li data-list-item-id="e3b541f71999db66774b52631525421fc"><code spellcheck="false">Fetch Operands</code>: If the instruction requires data, the control unit directs the data to be fetched from memory or a register.</li><li data-list-item-id="e51d708616fff7d53c42726821ec2e165"><code spellcheck="false">Execute</code>: Sends a signal to the relevant component (e.g. ALU) to perform the task.</li><li data-list-item-id="e4e97bb4c1f9d0e1f5976068ced8ac7c9"><code spellcheck="false">Store/Write-back</code>: Stores the result back into a register or memory.</li></ul><p><br>&nbsp;</p><h2>III. Memory Architecture<a id="iii-memory-architecture" class="toc-anchor" name="iii-memory-architecture" href="#iii-memory-architecture">#</a></h2><h3>Memory Fundamentals &amp; Hardware (Lecture 3)<a id="memory-fundamentals-amp-hardware-lecture-3" class="toc-anchor" name="memory-fundamentals-amp-hardware-lecture-3" href="#memory-fundamentals-amp-hardware-lecture-3">#</a></h3><h4>1. Memory Hierarchy (存储层次结构)<a id="1-memory-hierarchy-存储层次结构" class="toc-anchor" name="1-memory-hierarchy-存储层次结构" href="#1-memory-hierarchy-存储层次结构">#</a></h4><p>Memory is organized in a pyramid based on speed, capacity, and cost.</p><ul><li data-list-item-id="e5d93aa72bbb0baa208a583dd0c669abe"><strong>CPU Registers (寄存器):</strong> The top of the pyramid. Fastest access, smallest capacity, located inside the CPU.</li><li data-list-item-id="eecbfddd2b7e69fc0be852755f33290ed"><strong>Cache (缓存):</strong> L1, L2, L3 SRAM. Very fast, bridges the speed gap between CPU and Main Memory.</li><li data-list-item-id="ed26975a0c756dbc86ecedf7f8afe58d1"><strong>Main Memory (主存):</strong> DRAM. Larger capacity, slower than cache.</li><li data-list-item-id="eeae9756f80ce459438eee968dcc6028f"><strong>Secondary Memory (二级存储):</strong> Flash or Magnetic (HDD). Slowest, largest capacity, non-volatile.</li></ul><blockquote><p><strong>Note:</strong> In embedded systems, code execution usually happens directly from <strong>Flash Memory</strong>.</p></blockquote><h4>2. Building Blocks (构建模块)<a id="2-building-blocks-构建模块" class="toc-anchor" name="2-building-blocks-构建模块" href="#2-building-blocks-构建模块">#</a></h4><ul><li data-list-item-id="eb340009f875123617ae614d393666862"><strong>Logic Gates (逻辑门):</strong> The basic unit (AND, OR, NOT) used to create memory circuits.</li><li data-list-item-id="e8ce7156ab196ba29aad4b270c9fad733"><strong>Latch (锁存器):</strong> Created by combining gates. It can store 1 bit of data. A "Gated Latch" has a "Write Enable" line.</li><li data-list-item-id="eed5119e6489e6619bca0a1c9323c6029"><strong>Register (寄存器):</strong> A group of latches sharing a common "Write Enable" line. An 8-bit register holds 8 bits of data.</li><li data-list-item-id="eb5bf0cf887156a3c9cf796f3638006b8"><strong>RAM Construction:</strong> A matrix of latches addressed by Row and Column selectors (Multiplexer).</li></ul><h4>3. Memory Characteristics (存储特性)<a id="3-memory-characteristics-存储特性" class="toc-anchor" name="3-memory-characteristics-存储特性" href="#3-memory-characteristics-存储特性">#</a></h4><ul><li data-list-item-id="e5edc631a28abe46bc2f9fcb655943f87"><strong>Capacity (容量):</strong> The amount of storage. Embedded systems typically range from Kilobytes to Megabytes.</li><li class="ck-list-marker-bold" data-list-item-id="e526b5c94ed7b151b8cbb594a0dfcfbb9"><strong>Volatility (易失性):</strong><ul><li data-list-item-id="e8248ce8c07e44f0120c444def9086bbd"><strong>Volatile (易失性):</strong> Loses data when power is off (e.g., SRAM, DRAM, Registers).</li><li data-list-item-id="ead1268506d4d632671db57276bfa037c"><strong>Non-Volatile (非易失性):</strong> Retains data without power (e.g., ROM, Flash, EEPROM).</li></ul></li><li data-list-item-id="ee7a34a2e0ebd17ae27f4d99f24ce0e95"><strong>Access Method (访问方式):</strong> <strong>Random Access (随机访问)</strong> allows accessing any location instantly given an address.</li><li data-list-item-id="e61f1d920ee56eac8b6c9088104ff6d7e"><strong>Latency (延迟):</strong> The time taken to transfer a single word of data to/from memory.</li></ul><p><br>&nbsp;</p><h3>Memory Architecture &amp; Segments (Lecture 4)<a id="memory-architecture-amp-segments-lecture-4" class="toc-anchor" name="memory-architecture-amp-segments-lecture-4" href="#memory-architecture-amp-segments-lecture-4">#</a></h3><h4>1. The Platform &amp; Memory Map (平台与内存映射)<a id="1-the-platform-amp-memory-map-平台与内存映射" class="toc-anchor" name="1-the-platform-amp-memory-map-平台与内存映射" href="#1-the-platform-amp-memory-map-平台与内存映射">#</a></h4><ul><li data-list-item-id="e98bd5fcfdcffa3cd59aba41260b997e2"><strong>Platform:</strong> Includes the CPU, the Integrated Circuit (IC), and Peripherals.</li><li data-list-item-id="efc5b6a5910e9326cc481911561fd4fe4"><strong>Memory Map (内存映射):</strong> The CPU views memory as a linear array of addresses. Different address ranges are assigned to Flash (Code), SRAM (Data), and Peripherals.</li></ul><h4>2. CPU Registers (ARM Cortex-M0+)<a id="2-cpu-registers-arm-cortex-m0" class="toc-anchor" name="2-cpu-registers-arm-cortex-m0" href="#2-cpu-registers-arm-cortex-m0">#</a></h4><p>Registers are the most tightly integrated memory.</p><ul><li data-list-item-id="ecbce451e181d56209f5b853ead1289be"><strong>General Purpose (通用寄存器):</strong> <code spellcheck="false">R0</code> - <code spellcheck="false">R12</code>, used for operations and operands.</li><li class="ck-list-marker-bold" data-list-item-id="eaafc9bbc4e081f1d6aaa9577b208a0cc"><strong>Special Purpose (专用寄存器):</strong><ul><li data-list-item-id="eb5bf99f337249e51a89d8e2f2cde9f12"><strong>SP (</strong><code spellcheck="false"><strong>R13</strong></code><strong> - Stack Pointer):</strong> Points to the top of the stack (MSP or PSP).</li><li data-list-item-id="e8cd44af94b57ee9bfa03c4464367cf3f"><strong>LR (</strong><code spellcheck="false"><strong>R14</strong></code><strong> - Link Register):</strong> Stores return addresses for function calls.</li><li data-list-item-id="e8e44e311724e83015f1c8fc9f7e66afa"><strong>PC (</strong><code spellcheck="false"><strong>R15</strong></code><strong> - Program Counter):</strong> Tracks the address of the current instruction.</li></ul></li></ul><h4>3. Memory Segments (内存段)<a id="3-memory-segments-内存段" class="toc-anchor" name="3-memory-segments-内存段" href="#3-memory-segments-内存段">#</a></h4><p>A program is divided into specific segments in memory:</p><ul><li class="ck-list-marker-bold" data-list-item-id="e1e49c78e4973f53b2385ea0e95825e0e"><strong>Code Segment (代码段):</strong><ul><li data-list-item-id="e8f5bfeb6a8e8f15b3f7703370183abb3">Located in <strong>Flash</strong> (Non-volatile).</li><li data-list-item-id="e5fd42623f158c3306262cf7954aff5bf">Read-Only.</li><li data-list-item-id="e3c450894a30e450b22745c827a0cc784">Stores instructions and constants.</li></ul></li><li class="ck-list-marker-bold" data-list-item-id="e0ff1653b64a941055149999f2910a791"><strong>Data Segment (数据段):</strong><ul><li data-list-item-id="e105c7772e71a59d69edc4626b5bf378d">Located in <strong>SRAM</strong> (Volatile).</li><li data-list-item-id="eca88ee12c944d7e352acdb4ca9cf19ea">Stores variables and the stack.</li><li class="ck-list-marker-bold" data-list-item-id="eb9ba26b8462d5f50179478af1beae62e"><strong>Sub-segments of Data Memory:</strong><ol><li data-list-item-id="ed056ebf0adb847d3f495eb7fb4bdbaa3"><strong>Stack (栈):</strong> Temporary storage for local variables and function parameters. It grows <strong>down</strong>.</li><li data-list-item-id="e165ce46987dc95ff56ab868fc02a94e0"><strong>Heap (堆):</strong> Dynamic storage (e.g., <code spellcheck="false">malloc</code>). It grows <strong>up</strong>.</li><li data-list-item-id="e82f0456c5ec0284b2d5bcd1942d74867"><strong>Data:</strong> Initialized global and static variables (Non-zero).</li><li data-list-item-id="e08f7e427c39f5ee5b5b2f2b5b1cfa550"><strong>BSS:</strong> Zero-initialized or uninitialized global/static variables.</li></ol></li></ul></li></ul><h4>4. Variable Scope &amp; Lifetime (变量作用域与生命周期)<a id="4-variable-scope-amp-lifetime-变量作用域与生命周期" class="toc-anchor" name="4-variable-scope-amp-lifetime-变量作用域与生命周期" href="#4-variable-scope-amp-lifetime-变量作用域与生命周期">#</a></h4><ul><li data-list-item-id="eb1f70f6fe88e75adfe7694b844e5f0c8"><strong>Global Variables (全局变量):</strong> Allocated at compile time. Exist for the lifetime of the program. Stored in Data or BSS segments.</li><li data-list-item-id="edfd264e7e79c19e11159dc28c8c4cdb6"><strong>Local Variables (局部变量):</strong> Allocated at run-time. Exist only during the function/block execution. Stored in the <strong>Stack</strong>.</li></ul><h3>Summary Q&amp;A<a id="summary-q-amp-a" class="toc-anchor" name="summary-q-amp-a" href="#summary-q-amp-a">#</a></h3><p><strong>1. How the memory works?</strong> Memory works by using digital circuits to store binary states (0s and 1s). It starts with basic logic gates (AND/OR/NOT) which form <strong>latches</strong>. Multiple latches form <strong>registers</strong> (to store bytes), and massive arrays of these latches form <strong>RAM</strong>, allowing data to be written or read based on specific addresses selected by a multiplexer .</p><p><strong>2. What are different types of memory?</strong> Memory is primarily categorized by volatility:</p><ul><li data-list-item-id="e2d2b428236f7a38a6b2b7b6ddb3099ea"><strong>Volatile Memory:</strong> Requires power to maintain data (e.g., <strong>SRAM</strong> for cache/internal data, <strong>DRAM</strong> for main memory).</li><li data-list-item-id="e26295299cd112e15e408bbcc78e0ca8d"><strong>Non-Volatile Memory:</strong> Retains data without power (e.g., <strong>Flash</strong> for code storage, <strong>EEPROM</strong>, <strong>ROM</strong>).</li></ul><p><strong>3. What is the Memory hierarchy in embedded systems?</strong> It is a structure balancing speed and cost:</p><ul><li data-list-item-id="eb3a443eb95a7e51093ed910cff4467c6"><strong>Top:</strong> CPU Registers (Fastest, Smallest).</li><li data-list-item-id="e1562ba4c44cb1ae6893e8ed921a6720c"><strong>Middle:</strong> SRAM (Fast, used for Data/Stack/Heap).</li><li data-list-item-id="ec0ac2a6f60f1a14b32c2403414c6abbb"><strong>Bottom:</strong> Flash (Slower, High Capacity, used for Code storage) .</li></ul><p><strong>4. How we communicate (read/write) with memory?</strong> The CPU communicates via a bus controller using three main signals:</p><ul><li data-list-item-id="efa98d7d3386edc7e222ba5e1df393365"><strong>Address Bus:</strong> Specifies <em>where</em> to read/write.</li><li data-list-item-id="ed56773257d5a8812d1ff8989ddb0db14"><strong>Data Bus:</strong> Carries the actual information.</li><li data-list-item-id="e51b1ee0f67065ae9ca21e26183987ef6"><strong>Control Bus (Read/Write/Enable):</strong> Signals whether to retrieve data or store it.</li></ul><p><strong>5. What is Data Memory vs. Code Memory?</strong></p><ul><li data-list-item-id="eb21c367c0bf675b820acea5719de5d8d"><strong>Code Memory (Flash):</strong> Stores the program instructions and constants. It is non-volatile and usually Read-Only during runtime.</li><li data-list-item-id="e90d9e3624f0a125e824a717c8d5407d3"><strong>Data Memory (SRAM):</strong> Stores variable data (variables, stack, heap). It is volatile and allows Read/Write operations during execution.</li></ul><p><strong>6. Stack vs. Heap?</strong></p><ul><li data-list-item-id="e8e29f05373a3def7c9f2d9f3e116b19b"><strong>Stack:</strong> Used for static memory allocation (local variables, function calls). It is ordered (LIFO - Last In First Out) and managed automatically by the compiler. It grows downwards in memory.</li><li data-list-item-id="e2a9ad76225aea9d83a0eba5d8044d2ce"><strong>Heap:</strong> Used for dynamic memory allocation (user-managed via <code spellcheck="false">malloc</code>/<code spellcheck="false">free</code>). It is unordered and grows upwards in memory.</li></ul><p><br>&nbsp;</p><h2>IIII. I/O Architecture and Program Execution<a id="iiii-i-o-architecture-and-program-execution" class="toc-anchor" name="iiii-i-o-architecture-and-program-execution" href="#iiii-i-o-architecture-and-program-execution">#</a></h2><h3>1. I/O Architecture (输入/输出架构)<a id="1-i-o-architecture-输入-输出架构" class="toc-anchor" name="1-i-o-architecture-输入-输出架构" href="#1-i-o-architecture-输入-输出架构">#</a></h3><h4>Digital to Analogue Converters (DAC, 数模转换器)<a id="digital-to-analogue-converters-dac-数模转换器" class="toc-anchor" name="digital-to-analogue-converters-dac-数模转换器" href="#digital-to-analogue-converters-dac-数模转换器">#</a></h4><p>DACs convert a digital binary signal (0s and 1s) into a continuous analog output signal.</p><ul><li data-list-item-id="ecd382d1d2f7a38271e44bc53509de5e8"><strong>Mechanism:</strong> Uses components like <strong>String Resistor Ladders (电阻梯)</strong> with switches to select a voltage level corresponding to the digital input.</li><li data-list-item-id="ed255e72e795a8566f611da321561552d"><strong>Key Formula:</strong>&nbsp;<span class="math-tex">\(V_{out} = V_{ref} \times (\frac{D}{2^n})\)</span>&nbsp;where&nbsp;<span class="math-tex">\(D\)</span>&nbsp;is the digital value and&nbsp;<span class="math-tex">\(n\)</span>&nbsp;is the number of bits.</li><li class="ck-list-marker-bold" data-list-item-id="ef265f00c4f6886e88f97d45f2b9ad5f4"><strong>Common Errors (常见误差):</strong><ul><li data-list-item-id="e23bf379a8d34331c908dae587e306e83"><strong>Offset Error (失调误差):</strong> Constant difference from the ideal output.</li><li data-list-item-id="ea7903a0886b2eefe1dbae6ed6a173f4f"><strong>Gain Error (增益误差):</strong> Difference proportional to the signal magnitude.</li><li data-list-item-id="ebc7ba97f3f2af8b544ed5016ff88289a"><strong>Integral Non-Linearity (INL, 积分非线性):</strong> Deviation of the characteristic curve from a straight line.</li></ul></li></ul><h4>Analogue to Digital Converters (ADC, 模数转换器)<a id="analogue-to-digital-converters-adc-模数转换器" class="toc-anchor" name="analogue-to-digital-converters-adc-模数转换器" href="#analogue-to-digital-converters-adc-模数转换器">#</a></h4><p>ADCs convert real-world analog signals (voltage) into digital data for the processor.</p><ul><li class="ck-list-marker-bold" data-list-item-id="e2a161cb721f7a31bf16febb00eb3e214"><strong>Process Flow:</strong><ol><li data-list-item-id="ef10bb3a72597ee1fbfa6568a4db28d1c"><strong>Transducer (传感器):</strong> Converts physical quantity to voltage.</li><li data-list-item-id="e1eb184eb6b7a5fddb3b51caf0388c501"><strong>Signal Conditioning (信号调理):</strong> Amplifies and filters noise.</li><li data-list-item-id="e8bb7b1e3353d7dfa8c5d83f78f54c6d9"><strong>Sample and Hold (采样保持):</strong> Uses a capacitor to hold the voltage steady during conversion.</li></ol></li><li class="ck-list-marker-bold" data-list-item-id="e216af7248d4fc7d5c20d5c89c7e0cdd4"><strong>Types of ADC:</strong><ul><li class="ck-list-marker-bold" data-list-item-id="e47ddc261f31ee14773f8004e1ff5f03f"><strong>Flash ADC (闪存型 ADC):</strong><ul><li data-list-item-id="efce2d6d19b64b36603cb2b1c9df2a150">Uses a bank of <strong>Comparators (比较器)</strong> and a <strong>Priority Encoder (优先编码器)</strong> in parallel.</li><li data-list-item-id="ef4484ef69c9ad8707d5a1d256ba034b8"><strong>Pros:</strong> Extremely fast (up to 30 Msps).</li><li data-list-item-id="e514bb119e5f42a150d9c04733e3203b1"><strong>Cons:</strong> Expensive and complex (number of comparators doubles with each added bit).</li></ul></li><li class="ck-list-marker-bold" data-list-item-id="ecca3a54cc010ae153db6107a3c4763e4"><strong>Successive Approximation Register ADC (SAR ADC, 逐次逼近型 ADC):</strong><ul><li data-list-item-id="eafde24b32cf6427bc3fce8249dc107aa">Uses a comparator and a DAC to test bits one by one (binary search).</li><li data-list-item-id="ee659ee8a23b9292b788d9570e11443a3"><strong>Pros:</strong> Reasonable cost, accurate, low power. Used in <strong>Raspberry Pi Pico</strong> (12-bit).</li></ul></li></ul></li><li class="ck-list-marker-bold" data-list-item-id="e4a24997eb84d8043f1a0776dd2bb8d2c"><strong>Sampling Theory (采样理论):</strong><ul><li data-list-item-id="e549e77e7e06a07603eac139059481dbe"><strong>Quantization (量化):</strong> Approximating continuous values to discrete steps. Max error is&nbsp;<span class="math-tex">\(\frac{1}{2} V_{LSB}\)</span>.</li><li data-list-item-id="e795815df80b968ad8ec8c793ebdf4fbc"><strong>Nyquist Theorem (奈奎斯特定理):</strong> Sampling frequency must be at least twice the highest signal frequency (<span class="math-tex">\(f_s \ge 2f_{max}\)</span>) to avoid <strong>Aliasing (混叠)</strong>.</li></ul></li></ul><h4>Pulse Width Modulation (PWM, 脉冲宽度调制)<a id="pulse-width-modulation-pwm-脉冲宽度调制" class="toc-anchor" name="pulse-width-modulation-pwm-脉冲宽度调制" href="#pulse-width-modulation-pwm-脉冲宽度调制">#</a></h4><p>A digital technique to simulate analog voltage by controlling the "ON" time of a pulse.</p><ul><li data-list-item-id="e06a602bd993400721c0eebd3f6dfab0c"><strong>Duty Cycle (占空比):</strong> The ratio of "ON" time to the total period.<ul><li data-list-item-id="e94da994cc1c0067e201f3045f32de2af">Longer ON time = Higher average voltage/speed.</li></ul></li><li data-list-item-id="eb505ba019f322ff8e76340c878748ae7"><strong>Applications:</strong> Controlling motor speed, LED brightness.</li><li data-list-item-id="eb7a3d035ce544f24d3512e63a455e837"><strong>RP2040:</strong> Has 8 PWM slices (16 outputs) and all GPIOs can be configured as PWM.</li></ul><h3>2. Program Execution (程序执行)<a id="2-program-execution-程序执行" class="toc-anchor" name="2-program-execution-程序执行" href="#2-program-execution-程序执行">#</a></h3><h4>The Instruction Cycle (指令周期)<a id="the-instruction-cycle-指令周期" class="toc-anchor" name="the-instruction-cycle-指令周期" href="#the-instruction-cycle-指令周期">#</a></h4><p>The processor executes a program by repeating a cycle:</p><ol><li data-list-item-id="e108f86a36a7ec23ac9d297103996ba56"><strong>Load/Fetch (取指):</strong> Read the instruction from memory.</li><li data-list-item-id="e46626b60627d978d33c83af65990a5c0"><strong>Decode (译码):</strong> Figure out the operation and required data.</li><li data-list-item-id="e86262636c836eec2f421af20c5584db1"><strong>Execute (执行):</strong> Perform the computation (ALU operations like Add, Sub).</li><li data-list-item-id="e360b89fd83f60d31e17312c6062ca66b"><strong>Next Instruction:</strong> Update the Program Counter (PC) to the next address or jump target.</li></ol><h3>Summary Q&amp;A<a id="summary-q-amp-a" class="toc-anchor" name="summary-q-amp-a" href="#summary-q-amp-a">#</a></h3><ol><li data-list-item-id="e357fad1ee8b242190e00fac210a2cd6e">What is the I/O interface in embedded system?</li></ol><p>The I/O interface consists of mechanisms and buses (like AHB/APB bridges) that allow the CPU to communicate with external peripherals (sensors, motors) and memory, enabling the system to interact with the physical world.</p><ol><li data-list-item-id="e87ff05dab305348085432ca85de9a729">How Digital to Analogue Converters (DAC) works?</li></ol><p>A DAC takes a binary number (digital code) and closes specific switches in a resistor network (like a string resistor ladder). This selects a specific voltage level from a reference voltage to output an analog signal proportional to the digital input.</p><ol><li data-list-item-id="e99ee73f4653ecc162b541ed5d6a5fa8e">What is the Analogue to Digital Converters (ADC)?</li></ol><p>An ADC is a device that samples a continuous analog voltage at fixed intervals and quantizes it into a discrete digital binary value. It is essential for processing sensor data (temperature, sound, etc.).</p><ol><li data-list-item-id="eb76df6d094b3be495ffdda872d72fc10">How we use the Pulse Width Modulation (PWM)?</li></ol><p>PWM is used to control the power delivered to a load (like a motor or LED) without dissipating heat via resistance. By switching a digital output ON and OFF rapidly and varying the Duty Cycle, we can change the average voltage and current seen by the load, effectively controlling speed or brightness efficiently.</p><ol><li data-list-item-id="e6ae56c87be250b74bf9f5a65e05f9fd9">Program execution?</li></ol><p>Program execution is the continuous process where the CPU fetches instructions from memory (Code/Flash), decodes them to understand the command, fetches necessary data from registers or memory, executes the operation (arithmetic or logic), and then moves to the next instruction.</p><p><br>&nbsp;</p><h2>V. Embedded Networking and Communications<a id="v-embedded-networking-and-communications" class="toc-anchor" name="v-embedded-networking-and-communications" href="#v-embedded-networking-and-communications">#</a></h2><h3>1. Finite State Machine (FSM / 有限状态机)<a id="1-finite-state-machine-fsm-有限状态机" class="toc-anchor" name="1-finite-state-machine-fsm-有限状态机" href="#1-finite-state-machine-fsm-有限状态机">#</a></h3><ul><li data-list-item-id="e73052dbd5d62cf3c0f45d8b50b17afd5"><strong>Definition:</strong> A model of behavior consisting of states, transitions, and actions to represent systems that change state in response to inputs.</li><li data-list-item-id="eca530693d693fa0bb5db006d477fcab9"><strong>Elements:</strong> Finite set of states (including an initial state), inputs, outputs, state transition logic, and output logic .</li><li data-list-item-id="e2bab532872c1bee0ee4a536b1ca84cdf"><strong>Moore Machine (摩尔型有限状态机):</strong> A specific type of FSM where current output values are determined <strong>only</strong> by the current state.</li></ul><h3>2. I/O Operations (输入/输出操作)<a id="2-i-o-operations-输入-输出操作" class="toc-anchor" name="2-i-o-operations-输入-输出操作" href="#2-i-o-operations-输入-输出操作">#</a></h3><ul><li data-list-item-id="eb810750aa289fb255e158ad8eee3c609"><strong>Mechanism:</strong> Uses buffer registers (DATAIN/DATAOUT) and status control flags (SIN/SOUT).</li><li data-list-item-id="e2786fa51331c61315cb1589e633f1f19"><strong>Input:</strong> SIN flag sets to 1 when data is in the buffer; cleared when the processor reads it .</li><li data-list-item-id="e867f3240abc0b0e7aa147a88cafeb94a"><strong>Output:</strong> SOUT flag indicates the display is ready to receive a character. <img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251227_161849.png" width="1141" height="574"></li></ul><h3>3. I/O Synchronization (I/O 同步)<a id="3-i-o-synchronization-i-o-同步" class="toc-anchor" name="3-i-o-synchronization-i-o-同步" href="#3-i-o-synchronization-i-o-同步">#</a></h3><p>Synchronization bridges the speed mismatch between communicating devices. There are five main mechanisms:</p><ol><li data-list-item-id="ec28ce4f9d8e598ada719b4509b011ed2"><strong>Blind Cycle (盲周期):</strong> Software waits a fixed time assuming I/O completes. Used for predictable, short tasks (e.g., LCD, stepper motors) .</li><li data-list-item-id="e294025a40ef363bfa13d34a39ec47437"><strong>Busy Wait (忙等待):</strong> Software loop continuously checks the I/O status flag until done.</li><li data-list-item-id="e07fa095b96752a7eaae5dc2840707a3d"><strong>Interrupt (中断):</strong> Hardware triggers a special software execution (ISR) when data is ready or the device is idle.</li><li data-list-item-id="ef15ee814010f3a0e419c4fe8b19fbe2e"><strong>Periodic Polling (周期性轮询):</strong> Uses a clock interrupt to check I/O status at regular intervals.</li><li data-list-item-id="eed612a08ec198c6b6622a2b85345fb3e"><strong>Direct Memory Access (DMA / 直接存储器访问):</strong> Transfers data directly between I/O and memory without CPU intervention.</li></ol><p><img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251227_170248.png" width="1163" height="573"></p><h3>4. I/O Access Modes (I/O 访问模式)<a id="4-i-o-access-modes-i-o-访问模式" class="toc-anchor" name="4-i-o-access-modes-i-o-访问模式" href="#4-i-o-access-modes-i-o-访问模式">#</a></h3><ul><li data-list-item-id="e3db2534b6733a95ddc3f6dd0082a7d84"><strong>Programmed I/O (程序控制 I/O):</strong> CPU controls the whole transfer and stays in a loop waiting for the device. Wasteful of CPU time .</li><li data-list-item-id="eb9596326f215f5c1ea5f402502918e24"><strong>Interrupt-Driven I/O (中断驱动 I/O):</strong> Peripheral initiates transfer via signal; CPU only stops current execution when needed. More efficient .</li><li data-list-item-id="ea6ad56f640145dbc9340899f343f2529"><strong>DMA:</strong> Specialized unit handles block transfers. CPU sets start address/size, and DMA interrupts CPU only upon completion .</li></ul><h3>5. Buses (总线)<a id="5-buses-总线" class="toc-anchor" name="5-buses-总线" href="#5-buses-总线">#</a></h3><ul><li data-list-item-id="e8807d25517857cf25e4b79dd8b0a239f"><strong>Definition:</strong> Communication path interconnecting CPU, memory, and I/O.</li><li data-list-item-id="ebcabdb8c6df9337b871e3e308674c347"><strong>Types:</strong> Control bus, Address bus, Data bus .</li><li class="ck-list-marker-bold" data-list-item-id="eb95daed5f3abe7415ba05e4da3d4deb9"><strong>Timing Protocols:</strong><ul><li class="ck-list-marker-bold" data-list-item-id="ea6bf2f48e0aa08a26cc228f98299f772"><strong>Synchronous (同步):</strong><ul><li data-list-item-id="ecb8afc8c81cfde8318998f1f24ffa253">The timing information for all devices are driven from a common clock signal.</li><li data-list-item-id="ea1c9d1d8cc3b103c102c7fbaf754a9cd">One data transfer can take place during one bus cycle.</li></ul></li><li data-list-item-id="e0f051a28c1d1361aae4b98ad056bae4f"><strong>Asynchronous (异步):</strong> Uses handshaking signals (<strong>Master-ready</strong> and <strong>Slave-ready</strong>) instead of a common clock .</li></ul></li></ul><h3>6. Parallel Port (并行端口)<a id="6-parallel-port-并行端口" class="toc-anchor" name="6-parallel-port-并行端口" href="#6-parallel-port-并行端口">#</a></h3><ul><li data-list-item-id="e442bf4ada6b26fae80cc59da8b6f9468"><strong>Function:</strong> Transfers multiple bits (e.g., 8 or 16) simultaneously.</li><li data-list-item-id="e14e314b3e4610039a96cd24fe59cba68"><strong>Pros/Cons:</strong> Faster per cycle but suffers from cross-talk (electrical interference), bulky cables, and signal degradation over distance.</li><li data-list-item-id="e31c0c5283504ca06aa7e5bb7767dcbc0"><strong>Usage:</strong> Used for Keyboards (Input) and Printers (Output) using status lines like <code spellcheck="false">Valid</code> or <code spellcheck="false">Idle</code>.</li></ul><h3>7. Serial Port (串行端口)<a id="7-serial-port-串行端口" class="toc-anchor" name="7-serial-port-串行端口" href="#7-serial-port-串行端口">#</a></h3><ul><li data-list-item-id="e482109615818776d575bc4d3c76c6741"><strong>Function:</strong> Transmits data one bit at a time. The speed is defined by the <strong>Bit Rate (比特率)</strong>.</li><li class="ck-list-marker-bold" data-list-item-id="eb70d57c2efde80515cc2a5c58ba31032"><strong>UART (Universal asynchronous receiver transmitter 通用异步收发传输器):</strong><ul><li data-list-item-id="ed29e6fd0240a2a8d6fc7ff4f1635d66c"><strong>Frame Structure:</strong> Idle -&gt; Start Bit (0) -&gt; Data Bits (usually 8) -&gt; Parity Bit (Optional) -&gt; Stop Bit (1).</li><li data-list-item-id="ed5961bd412666fdb3aa7bd3dc78f1392"><strong>FIFO (First In First Out / 先入先出):</strong> Buffers data to separate production and consumption rates, improving efficiency.</li><li data-list-item-id="ed52329014266de7769dfec11e91a515f"><strong>Parity:</strong> Used for error checking (Even/Odd). Detects single-bit errors but cannot locate them.</li></ul></li></ul><p><img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251227_171633.png" width="894" height="289"></p><p>Example: A UART port is configured with the parameters:</p><ul><li data-list-item-id="e6eeab3b71ec5718a4284f9014a5ba614">baud rate: 9600</li><li data-list-item-id="e570d94ed201ba237a45b5a55fe3e8ca9">data bits: 8</li><li data-list-item-id="e2fb08073ba6d10e314685955cc476eb8">stop bit: 1</li><li data-list-item-id="eff9012bb6843028eaac9525a788d1004">start bit: 1</li><li data-list-item-id="e62dd9e202ec5d8527ce6d492504dbbe7">parity bit: none How long does it take to transmit 5k bytes data?</li></ul><span class="math-tex">\[5000 \times \frac{8+1+1}{9600}\]</span><h3>8. Serial Standards<a id="8-serial-standards" class="toc-anchor" name="8-serial-standards" href="#8-serial-standards">#</a></h3><ul><li data-list-item-id="eaca03fbbb9d45f399244745b92b9e4b6"><strong>RS-232:</strong> Single-ended signaling. Low speed (max 20 Kbps at 50ft), short distance, point-to-point (DTE to DCE).</li><li data-list-item-id="ea2bd6668d9d41f6aafc44b6c6874725a"><strong>RS-485:</strong> Differential signaling (noise cancellation). High speed (<span class="math-tex">\(10~Mbit/s\)</span>), long distance (4000 ft), used in industrial applications.</li></ul><h3>9. Board-Level Protocols<a id="9-board-level-protocols" class="toc-anchor" name="9-board-level-protocols" href="#9-board-level-protocols">#</a></h3><ul><li class="ck-list-marker-bold" data-list-item-id="e36abd7b2d004b503ccfd1046103d0946"><strong>SPI (Serial Peripheral Interface / 串行外设接口):</strong><ul><li data-list-item-id="eae2314a38e765e6c7321a3ed0b056f2e"><strong>Wires:</strong> 4 - Serial Clock (SCK), Slave Select (SS), Master Out Slave In (MOSI), Master In Slave Out (MISO).</li><li data-list-item-id="ebdf4cd7f6bb63e35fe5b6f4f0f155148"><strong>Features:</strong> Master/Slave, high speed, simple shift register logic.</li><li data-list-item-id="ef5a4c3cd9aad60ec83ca908392452082"><strong>Cons:</strong> No addressing, no flow control, no acknowledgements, no error checking.</li></ul></li></ul><p><img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251227_172233.png" width="499" height="240"></p><ul><li class="ck-list-marker-bold" data-list-item-id="e60189c91b02f063795bad35de66dea68"><strong>I2C (Inter-Integrated Circuit / 集成电路总线):</strong><ul><li data-list-item-id="e357d61fe8aa144720126b9950a25cbce"><strong>Wires:</strong> 2 - SCL (clock line) and SDA (data line).</li><li data-list-item-id="e3012fe0adb3e4a44f29e35c9ee9b80d9"><strong>Features:</strong> Address-based (supports multiple devices), uses Start/Stop conditions and ACKs.</li><li data-list-item-id="ec7618457109a802b289ac6ef58aa2204"><strong>Use case:</strong> Lower speed, multiple simple sensors.</li><li data-list-item-id="e46dfe7d40ca8348ea6cb00e13ee79ca4">SCL functions as a clock line and SDA can function as a 1-bit serial data line or as a 1-bit serial address line. A common ground is also required. <img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251227_172442.png" width="746" height="456"></li><li data-list-item-id="ee5b16c327fdebdf163cf1c9b3944c4b6"><strong>How I2C works</strong> ?<ul><li data-list-item-id="e9b1decd43959ea9962f6a04deb2d9c6d">Master issues a START condition (First pulls SDA low, then pulls SCL low). Master writes an address to the bus. Add a bit indicating whether it wants to read or write. Slaves that do not match address do not respond. A matching slave issues an ACK by pulling down SDA.</li><li data-list-item-id="ec10a728745f3b165bd09c8e4fcec4e9e">Either master or slave transmits one byte Receiver issues an ACK. This step may repeat.</li><li data-list-item-id="ee077aaa860cbad4cd2cd984f31fa984d">Master issues a STOP condition First releases SCL, then releases SDA At this point the bus is free for the other transaction</li></ul></li></ul></li></ul><h3>10. High-Level Protocols<a id="10-high-level-protocols" class="toc-anchor" name="10-high-level-protocols" href="#10-high-level-protocols">#</a></h3><ul><li data-list-item-id="ed9d22239dd326e5ea26acbec8c7feafc"><strong>Medium-end:</strong> Modbus, Profibus, CAN.</li><li data-list-item-id="e38f23436031ffe34bdf37f6beea0bc1c"><strong>High-end:</strong> Ethernet, Profinet.</li></ul><h3>Summary Q&amp;A<a id="summary-q-amp-a" class="toc-anchor" name="summary-q-amp-a" href="#summary-q-amp-a">#</a></h3><p><strong>1. What is the finite state machine?</strong> A Finite State Machine (FSM) is a software model used to represent systems that transition between a finite number of states based on input events. It helps separate the system's "policies" (what to do) from "mechanisms" (how to do it).</p><p><strong>2. What are input/output operations in embedded systems?</strong> These are operations where the processor transfers data to and from external devices (like keyboards or displays) using buffer registers (DATAIN/DATAOUT) and synchronizes the transfer using status flags (SIN/SOUT) to indicate when data is valid or the device is ready.</p><p><strong>3. What are the synchronization algorithms for software and hardware?</strong> The main algorithms are:</p><ul><li data-list-item-id="e7a6ea53a8e7034fad20b06558c4334b3"><strong>Blind Cycle:</strong> Waiting a fixed time.</li><li data-list-item-id="ea7b5c8bfe8287708554d46c13a9aa3f6"><strong>Busy Wait:</strong> Loops checking a status flag.</li><li data-list-item-id="e9320a8f8a5d881ef42fa5d61aed5736a"><strong>Interrupt:</strong> Hardware signals the CPU to stop and service the device.</li><li data-list-item-id="ea557671029182d5655d794d2acb80eee"><strong>Periodic Polling:</strong> Checking status at fixed clock intervals.</li><li data-list-item-id="e684f5c1a45037f13aad9765f2075a880"><strong>DMA:</strong> Hardware handles transfer directly to memory .</li></ul><p><strong>4. What are ways to access I/O devices and how each one is working?</strong></p><ul><li data-list-item-id="ed5ec0ce0c6bb9839f7f4dc970cbcd944"><strong>Programmed I/O:</strong> The software controls the entire transfer, keeping the CPU busy in a loop.</li><li data-list-item-id="e59bd3a8ff191c43a0388300e83cf76f7"><strong>Interrupt-Driven:</strong> The peripheral signals the CPU when it is ready, allowing the CPU to do other work until interrupted.</li><li data-list-item-id="e3cb7049d5acfd2897fe42967f8e35ccd"><strong>DMA:</strong> A dedicated controller transfers blocks of data between I/O and memory without the CPU's active involvement.</li></ul><p><strong>5. What are the buses and how they will work?</strong> Buses are communication paths (Data, Address, Control) connecting the CPU, memory, and I/O. They work via <strong>Synchronous</strong> timing (using a shared clock) or <strong>Asynchronous</strong> timing (using "Master-ready" and "Slave-ready" handshaking signals).</p><p><strong>6. What is parallel and serial port and what is the difference between them?</strong> A <strong>Parallel port</strong> transfers multiple bits (e.g., 8) simultaneously, making it faster per cycle but bulky and prone to interference. A <strong>Serial port</strong> transfers data one bit at a time sequentially. Serial ports are generally smaller, cheaper, and better for longer distances.</p><p><strong>7. What is embedded network?</strong> An embedded network refers to the communication protocols and physical interfaces used to connect microcontrollers to sensors, actuators, and other controllers. It ranges from low-level chip protocols (UART, SPI, I2C) to industrial standards (RS-485, CAN, Modbus).</p><p><strong>8. What is the difference between I2C and SPI and where to use them?</strong></p><ul><li data-list-item-id="e7ff7ac9f62646a640e213f1753825a4f"><strong>SPI</strong> uses 4 wires, is faster, and has no addressing overhead; it is best for high-bandwidth streams (like A/D converters).</li><li data-list-item-id="ef337de5f3e555d82127f1f92cb7d27f6"><strong>I2C</strong> uses 2 wires and device addresses; it is slower but uses fewer pins and is better for connecting many simple sensors on a board.</li></ul><p><strong>9. What are mid and high-end communication protocols?</strong></p><ul><li data-list-item-id="e04b3d8859cd1e893d1d11f90d94cbf83"><strong>Mid-end:</strong> Modbus, Profibus, and CAN (often used in industrial automation).</li><li data-list-item-id="e3e62e42ac4a0434ed306377e13ea22c6"><strong>High-end:</strong> Ethernet and Profinet (used for high-speed, complex networking) .</li></ul><p><br>&nbsp;</p><h2>VI. Real Time Operating Systems and Scheduling<a id="vi-real-time-operating-systems-and-scheduling" class="toc-anchor" name="vi-real-time-operating-systems-and-scheduling" href="#vi-real-time-operating-systems-and-scheduling">#</a></h2><h3>1. Data Checking Methods (数据校验方法)<a id="1-data-checking-methods-数据校验方法" class="toc-anchor" name="1-data-checking-methods-数据校验方法" href="#1-data-checking-methods-数据校验方法">#</a></h3><p>Reliability is crucial in embedded systems. Several methods are used to ensure data integrity during transmission.</p><ul><li class="ck-list-marker-bold" data-list-item-id="e4a3843cfd00d42665b7e77f4735beccd"><strong>Parity Check (奇偶校验):</strong><ul><li data-list-item-id="e204aab33dd73b0750aa1a2d646e0dd06"><strong>Mechanism:</strong> An extra bit (parity bit) is added to the data unit.<ul><li data-list-item-id="e3ff03c51ce870e65d3ac35590bdb180b"><strong>Even Parity (偶校验):</strong> The total number of 1s (including the parity bit) must be even.</li><li data-list-item-id="ebc5dfed7951730c43e1178d5a94558f3"><strong>Odd Parity (奇校验):</strong> The total number of 1s must be odd.</li></ul></li><li data-list-item-id="ebd4f472179a556cd1ddd79d789e50bbb"><strong>Limitation:</strong> It is a simple method but weak. It can detect single-bit errors but fails if an even number of bits are flipped (e.g., two errors might cancel each other out).</li></ul></li><li class="ck-list-marker-bold" data-list-item-id="e140b1007065d1532689761126ea790eb"><strong>Checksum (校验和):</strong><ul><li data-list-item-id="e07a8ed4c59afb27f0922d0d72c568740"><strong>Mechanism:</strong> The sender adds up the data segments and takes the 1's complement of the sum to generate the checksum. The receiver performs the same addition including the checksum; the result should be all 0s (in 1's complement arithmetic).</li><li data-list-item-id="e3983c79bf7ce3fce63fdb06f66c3fc31"><strong>Advantage:</strong> Better than parity checks as it can detect more complex error patterns.</li></ul></li></ul><p><img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251228_191925.png" width="971" height="493"></p><p><img alt="文章图片" loading="lazy" style="height:auto;" src="笔记_image_20251228_192008.png" width="967" height="488"></p><ul><li class="ck-list-marker-bold" data-list-item-id="e3f1bd46275da58b8abe297bf333feeb2"><strong>Cyclic Redundancy Check - CRC (循环冗余校验):</strong><ul><li data-list-item-id="e0a19af71e3702b58bc52810678aa1a44"><strong>Mechanism:</strong> Uses polynomial division (binary division with XOR operations). The sender divides the data by a "divisor" (polynomial) and appends the remainder to the data. The receiver divides the received message by the same divisor; if the remainder is 0, the data is correct.</li><li data-list-item-id="ea5eafdfd7dac1009016aff03b49e07df"><strong>Advantage:</strong> Highly effective at detecting burst errors and validates the <strong>order of bits</strong> (bit sequence), which simple parity cannot do.</li></ul></li></ul><h3>2. Real-Time Operating Systems - RTOS (实时操作系统)<a id="2-real-time-operating-systems-rtos-实时操作系统" class="toc-anchor" name="2-real-time-operating-systems-rtos-实时操作系统" href="#2-real-time-operating-systems-rtos-实时操作系统">#</a></h3><ul><li data-list-item-id="e8b66a16e256ece9238a09759a388f5f6"><strong>Definition:</strong> A system where correctness depends not only on the <strong>logical result</strong> (逻辑结果) but also on the <strong>time</strong> (时间) at which the result is produced.</li><li class="ck-list-marker-bold" data-list-item-id="e4653b389487fb19e8370a17ab583c936"><strong>Classifications:</strong><ol><li data-list-item-id="e292cbf924adceec937015b37172ca0ab"><strong>Soft Real-Time (软实时):</strong> Missing a deadline results in lower quality of service but is not catastrophic 灾难性的 (e.g., email delivery).</li><li data-list-item-id="ece93312f6fa3f99c032d97a42190935e"><strong>Hard Real-Time (硬实时):</strong> Missing a deadline causes total system failure or catastrophic consequences (e.g., airbag deployment, chemical plant pressure valve).</li><li data-list-item-id="e818cade705e6f0e098c3645833c5e2ab"><strong>Firm Real-Time (固实时):</strong> Lies between soft and hard. A few missed deadlines are tolerable (quality loss), but too many lead to failure (e.g., video streaming dropping frames).</li></ol></li></ul><h3>3. Threads (线程)<a id="3-threads-线程" class="toc-anchor" name="3-threads-线程" href="#3-threads-线程">#</a></h3><ul><li data-list-item-id="e1cf56d55021078695ca9ec88d7209aaf"><strong>Concept:</strong> A thread is a "program in action" (dynamic). While a <strong>Program</strong> (程序) is static code in ROM, a <strong>Thread</strong> breathes life into it using the processor.</li><li data-list-item-id="efd9e51d6302675656fd6f7328ff5b4a6"><strong>Structure:</strong> Each thread has its own <strong>Stack</strong> (栈) to store:<ul><li data-list-item-id="eab30ad494172ead5d729e38b54638376">Registers (e.g., PC, SP, PSR).</li><li data-list-item-id="e2ed721149dc08218e11c0aa7cec49c34">Local variables.</li></ul></li><li data-list-item-id="e9507a3c91c2b593bcaa8052583fb1dcf"><strong>Shared Resources:</strong> Threads share global memory and I/O but have private stacks.</li></ul><h3>4. Task States (任务状态)<a id="4-task-states-任务状态" class="toc-anchor" name="4-task-states-任务状态" href="#4-task-states-任务状态">#</a></h3><p>A thread transitions between different states controlled by the OS:</p><ul><li data-list-item-id="e22bfdba2c0d0cbd6da5b96380082831d"><strong>Active/Ready (就绪):</strong> Ready to run but waiting for the CPU.</li><li data-list-item-id="e6d5722aa5f139abf2278dba0c11cd601"><strong>Run (运行):</strong> Currently executing.</li><li data-list-item-id="efd57e7347a4031ccd694c841e149fbdf"><strong>Blocked (阻塞):</strong> Waiting for an external event (e.g., I/O, keyboard).</li><li data-list-item-id="e786e119ad32cca440136fee103155448"><strong>Sleep (休眠):</strong> Waiting for a fixed amount of time.</li></ul><h3>5. Real-Time Metrics<a id="5-real-time-metrics" class="toc-anchor" name="5-real-time-metrics" href="#5-real-time-metrics">#</a></h3><ul><li data-list-item-id="e74742d65e832189061db4fb5d57d4e2e"><strong>Latency (延迟):</strong> Time difference between when an event occurs and when the task starts running (<span class="math-tex">\(\Delta_i = T_i - E_i\)</span>).</li><li data-list-item-id="e320c1e70262bb16631b1f9f739c61e62"><strong>Jitter (抖动):</strong> The variation in timing; difference between the desired run time and the actual run time.</li></ul><h3>6. Scheduling Algorithms (调度算法)<a id="6-scheduling-algorithms-调度算法" class="toc-anchor" name="6-scheduling-algorithms-调度算法" href="#6-scheduling-algorithms-调度算法">#</a></h3><p>The <strong>Scheduler</strong> (调度器) creates the illusion of concurrent processing (并行处理).</p><ul><li class="ck-list-marker-bold" data-list-item-id="e55d83950ebcdc73dc80e7dd0af51084f"><strong>Rate Monotonic Scheduling - RMS (速率单调调度):</strong><ul><li data-list-item-id="e1efc5fb5cde2274a0b15b96ce60afe21"><strong>Type:</strong> <strong>Static Priority</strong> (静态优先级).</li><li data-list-item-id="ec595fc6aeaf9d55a63ac53c5d756ab93"><strong>Rule:</strong> Priority is determined by the <strong>Period</strong> (周期). Shorter period = Higher priority.</li><li data-list-item-id="ea49150d2f8994df5a1146fabd949d9ef"><p><strong>Schedulability Test:</strong> Sufficient but not necessary.&nbsp;</p><span class="math-tex">\[\sum_{i=1}^n \frac{C_i}{P_i} \le n(2^{\frac{1}{n}}-1)\]</span><p>&nbsp;(Utilization must be below a bound, approx 0.69 for large&nbsp;<span class="math-tex">\(n\)</span>).</p></li></ul></li><li class="ck-list-marker-bold" data-list-item-id="e64a5380564ed05aa644194c00ac4d96e"><strong>Earliest Deadline First - EDF (最早截止时间优先):</strong><ul><li data-list-item-id="ec0b3f4515ba24929ee8360548174091d"><strong>Type:</strong> <strong>Dynamic Priority</strong> (动态优先级).</li><li data-list-item-id="e05796e1a96110fd1d5435de8cc25cea2"><strong>Rule:</strong> Priority is based on the absolute <strong>Deadline</strong> (截止时间). The task with the closest deadline runs first.</li><li data-list-item-id="ed940d41b86863b7cac4c74cdcee9013b"><p><strong>Schedulability Test:</strong> Necessary and sufficient.&nbsp;</p><span class="math-tex">\[\sum_{i=1}^n \frac{C_i}{P_i} \le 1\]</span><p>&nbsp;(Total utilization must be less than or equal to 100%).</p></li></ul></li></ul><h3>7. Priority Inversion (优先级反转)<a id="7-priority-inversion-优先级反转" class="toc-anchor" name="7-priority-inversion-优先级反转" href="#7-priority-inversion-优先级反转">#</a></h3><ul><li data-list-item-id="ed799a7367ea69172f6564f1ea6acb909"><strong>Problem:</strong> A high-priority task is blocked by a low-priority task that holds a shared resource (critical section). If a medium-priority task preempts the low-priority task, the high-priority task is delayed indefinitely.</li><li data-list-item-id="e222689bacbc20f09aa98650242020976"><strong>Solution:</strong> <strong>Priority Inheritance Protocol (优先级继承协议)</strong>. When a low-priority task blocks a high-priority task, it temporarily inherits the high priority until it releases the resource.</li></ul><h3>8. Multi-Core Systems (多核系统)<a id="8-multi-core-systems-多核系统" class="toc-anchor" name="8-multi-core-systems-多核系统" href="#8-multi-core-systems-多核系统">#</a></h3><ul><li data-list-item-id="e60faf48347f7c888ab6e66c3b46f6bf4"><strong>Purpose:</strong> To handle increasing computational demands and allow parallel processing.</li><li data-list-item-id="ee885b89ebe95751570a3a04593d009d3"><strong>Structure:</strong> Multiple cores share caches and interconnects to process data (e.g., CATS/DOGS example in slides).</li></ul><h3>9. Network Flow Scheduling (网络流调度)<a id="9-network-flow-scheduling-网络流调度" class="toc-anchor" name="9-network-flow-scheduling-网络流调度" href="#9-network-flow-scheduling-网络流调度">#</a></h3><ul><li data-list-item-id="e2ce268917d36f602f0852b6a5dc44cba"><strong>Concept:</strong> Scheduling is modeled as a graph problem (<span class="math-tex">\(G(V,E)\)</span>) with a <strong>Source</strong> (<span class="math-tex">\(s\)</span>) and a <strong>Sink</strong> (<span class="math-tex">\(t\)</span>).</li><li class="ck-list-marker-bold" data-list-item-id="ed6f81809412dd3caa817d0b75bf8a46c"><strong>Mapping:</strong><ul><li data-list-item-id="e066343ed084109133b7d36ef51b78a31">Nodes: Jobs (<span class="math-tex">\(J\)</span>) and Time Frames (<span class="math-tex">\(F\)</span>).</li><li data-list-item-id="e4365b513de4fefd9805e2eef41222584">Edges: Represent capacity (execution time).</li></ul></li><li data-list-item-id="e538a405c741ed9467f094c5b1a610bae"><strong>Goal:</strong> Maximize flow from Source to Sink. If Max Flow equals the total execution time of all tasks, the set is schedulable.</li><li data-list-item-id="e60ac236594459029262af2c4cc850daa"><strong>Algorithm:</strong> <strong>Ford-Fulkerson Algorithm</strong>.<ul><li data-list-item-id="e79f69128877f4986468fa95cb9610413">Finds <strong>Augmenting Paths</strong> (增广路径) in the <strong>Residual Graph</strong> (残余图).</li><li data-list-item-id="e6b5032bae8979458cfc4a7057220288f"><strong>Max Flow Min Cut Theorem:</strong> The maximum flow is equal to the capacity of the minimum cut (bottleneck).</li></ul></li></ul><h3>10. Energy Efficient Scheduling (节能调度)<a id="10-energy-efficient-scheduling-节能调度" class="toc-anchor" name="10-energy-efficient-scheduling-节能调度" href="#10-energy-efficient-scheduling-节能调度">#</a></h3><ul><li data-list-item-id="ecef302efe81997bf10a49e925bd30906"><strong>Motivation:</strong> Processors use CMOS technology where dynamic power is the bottleneck.<ul><li data-list-item-id="e056156008dfdbba1acca77858b93f55b">Power&nbsp;<span class="math-tex">\(\propto V^2 \times F\)</span>&nbsp;(Voltage squared times Frequency).</li></ul></li><li data-list-item-id="e1fafbbab9a884fc505e032f213b93c8d"><strong>DVS / DVFS (动态电压频率调整):</strong> Dynamic Voltage (and Frequency) Scaling.<ul><li data-list-item-id="ec529964cafd26c026463f99e626dc5a9">Technique to reduce power by lowering voltage/frequency when peak performance is not needed.</li><li data-list-item-id="e8c7f37f1b541a44fd301a1c6afdf43d8"><strong>Trade-off:</strong> Lower frequency means tasks take longer to execute (<span class="math-tex">\(t_{execution}\)</span>&nbsp;increases), but power drops quadratically, resulting in net energy savings.</li></ul></li><li data-list-item-id="ec94f4604067b2ff5e48d08feb40d1d27"><strong>Static Voltage Scaling:</strong> Scaling factors are calculated offline to ensure utilization&nbsp;<span class="math-tex">\(\le 1\)</span>&nbsp;at the reduced frequency.</li></ul><h3>Summary Q&amp;A<a id="summary-q-amp-a" class="toc-anchor" name="summary-q-amp-a" href="#summary-q-amp-a">#</a></h3><p><strong>1. How Check Sum and CRC works for data check?</strong></p><ul><li data-list-item-id="eef60a9f57c39adf222a4819866f3ded7"><strong>Checksum:</strong> It works by summing up the data values being transmitted. The result (often the 1's complement of the sum) is sent along with the data. The receiver performs the same calculation; if the calculated sum matches the received checksum (result is zero), the data is assumed correct.</li><li data-list-item-id="efd8b10e0232bfe82ac9c104401d48d56"><strong>CRC (Cyclic Redundancy Check):</strong> It uses polynomial division. The data bits are treated as a large number and divided by a predetermined binary number (the polynomial). The remainder of this division is the CRC code appended to the message. The receiver divides the incoming message by the same number; a zero remainder indicates no errors. CRC is particularly good at detecting burst errors and bit-order errors.</li></ul><p><strong>2. What is parity check and why it is not a good approach?</strong></p><ul><li data-list-item-id="e1596cdb3b6cebde5c16d58edf06bff32"><strong>Parity Check</strong> is adding a single bit to a data block to make the total number of 1s either even (even parity) or odd (odd parity).</li><li data-list-item-id="ed03359cb6448a788f28980134c5ff996"><strong>Why it is not good:</strong> It is not robust because it can only detect an odd number of bit errors (e.g., 1, 3, 5 errors). If two bits flip (e.g., a 0 becomes 1 and a 1 becomes 0), the parity count remains the same, and the error goes undetected.</li></ul><p><strong>3. What is a real-time operation system?</strong></p><ul><li data-list-item-id="e2f89e62e8cc3cad09a9d929ec5b89624">An RTOS is an operating system where the correctness of the system depends not only on the logical results of the computations but also on the <strong>time</strong> at which those results are produced. It is designed to process data as it comes in, typically without buffering delays, to meet strict deadline constraints (Hard, Firm, or Soft).</li></ul><p><strong>4. What are the Threads and how they are used in RTOS?</strong></p><ul><li data-list-item-id="eb113ad88e23633e68432c4c3ffad729f">Threads are "light-weight processes" or programs in execution. Unlike static programs, threads have dynamic states (registers, stack, local variables). In an RTOS, multiple threads are used to perform different functions (tasks) concurrently. The RTOS switches the processor between these threads to achieve the desired system functionality.</li></ul><p><strong>5. What is Scheduler?</strong></p><ul><li data-list-item-id="e6e1c98baf4878099dd18b361182d7dcf">A scheduler is a kernel function in the Operating System responsible for deciding which thread should run at any given time. It switches between threads (context switching) to give the illusion of simultaneous execution (concurrency) on a single processor.</li></ul><p><strong>6. Explain RMS and EDF scheduling.</strong></p><ul><li data-list-item-id="ed47b040c1fc0f98232441913092cac12"><strong>RMS (Rate Monotonic Scheduling):</strong> A <strong>static</strong> priority algorithm for periodic tasks. It assigns priorities based on the task's period: the shorter the period, the higher the priority. It is optimal for static priorities.</li><li data-list-item-id="ebaca07d815bd7b27f49b9eff9847d9a5"><strong>EDF (Earliest Deadline First):</strong> A <strong>dynamic</strong> priority algorithm. It assigns priorities based on the absolute deadline of the current job: the task with the closest deadline gets the highest priority. It can achieve 100% CPU utilization.</li></ul><p><strong>7. What is priority inversion problem?</strong></p><ul><li data-list-item-id="e62a0daafd1c75162fe33328b93f47ec3">Priority Inversion occurs when a high-priority task is forced to wait for a lower-priority task to complete. This usually happens when the low-priority task holds a lock on a shared resource that the high-priority task needs. If a medium-priority task preempts the low-priority task while it holds the lock, the high-priority task is blocked for an indefinite period, potentially causing deadline misses.</li></ul><p><strong>8. What are multi-core processors and how they work?</strong></p><ul><li data-list-item-id="ec3235919b773fbe5ad6f8d2247fa0f4b">Multi-core processors are single chips containing two or more independent processing units (cores). They work by allowing multiple instructions or threads to run in parallel on separate cores, sharing resources like memory and interconnects, which increases overall performance and efficiency compared to single-core systems.</li></ul><p><strong>9. How Network flow formulation work?</strong></p><ul><li data-list-item-id="ea6ebc0300a9f2e5067984f061f27af04">Network flow formulation models the scheduling problem as a directed graph with a source and a sink. Jobs and Time Frames are represented as nodes. Edges represent the capacity (execution time) available. The problem is solved by finding the "Maximum Flow" from source to sink. If the max flow equals the total execution time required by all jobs, a valid schedule exists. Algorithms like Ford-Fulkerson are used to calculate this flow.</li></ul><p><strong>10. What is Energy Efficient Scheduling?</strong></p><ul><li data-list-item-id="ef87107d7f8d369e9b31ec0ed46f18ef7">Energy Efficient Scheduling involves managing the processor's execution speed to minimize energy consumption while still meeting task deadlines. The primary technique discussed is <strong>Dynamic Voltage Scaling (DVS)</strong> (or DVFS), where the processor's voltage and frequency are lowered when the workload is light. Since power consumption is proportional to the square of the voltage (<span class="math-tex">\(V^2\)</span>), reducing the speed slightly results in significant energy savings.</li></ul>
                
                
            </div>

            

            <footer id="content-footer">
                

                
                    

<div class="navigation">
    <a class="previous" href="../7CCEMEMB%20Embedded%20System%20Desig.html">7CCEMEMB Embedded System Design</a>
    <a class="next" href="../7CCEMTN1%20Telecommunications%20Ne.html">7CCEMTN1 Telecommunications Networks I</a>
</div>
                
            </footer>
        </div>
        
            <div id="toc-pane">
                <h3>本页内容</h3>
                <ul id="toc">
                    
                        

<li>
    <a href="#7ccememb-embedded-system-design">
        <span>7CCEMEMB Embedded System Design</span>
    </a>

    
</li>

                    
                        

<li>
    <a href="#i-introduction">
        <span>I. Introduction</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#types-of-different-embedded-systems">
        <span>Types of different embedded systems:</span>
    </a>

    
</li>

            
                

<li>
    <a href="#challenges-in-embedded-system-design">
        <span>Challenges in embedded system design:</span>
    </a>

    
</li>

            
                

<li>
    <a href="#real-time-embedded-systems">
        <span>Real-time embedded systems:</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#hard-real-time-systems">
        <span>Hard Real-Time systems</span>
    </a>

    
</li>

            
                

<li>
    <a href="#soft-real-time-system">
        <span>Soft Real-Time system:</span>
    </a>

    
</li>

            
        </ul>
    
</li>

            
                

<li>
    <a href="#power-management">
        <span>Power Management</span>
    </a>

    
</li>

            
                

<li>
    <a href="#embedded-systems-design-methodologies">
        <span>Embedded Systems Design Methodologies</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#requirements-form-sheet">
        <span>Requirements Form / Sheet</span>
    </a>

    
</li>

            
        </ul>
    
</li>

            
                

<li>
    <a href="#requirement">
        <span>Requirement</span>
    </a>

    
</li>

            
                

<li>
    <a href="#specification">
        <span>Specification</span>
    </a>

    
</li>

            
                

<li>
    <a href="#harvard-vs-von-neumann-architecture">
        <span>Harvard vs Von Neumann Architecture</span>
    </a>

    
</li>

            
        </ul>
    
</li>

                    
                        

<li>
    <a href="#ii-embedded-system-architecture">
        <span>II. Embedded System Architecture</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#computer">
        <span>Computer</span>
    </a>

    
</li>

            
                

<li>
    <a href="#microprocessor">
        <span>Microprocessor</span>
    </a>

    
</li>

            
                

<li>
    <a href="#microcontroller">
        <span>Microcontroller</span>
    </a>

    
</li>

            
                

<li>
    <a href="#functional-units-of-a-computer">
        <span>Functional Units of a computer</span>
    </a>

    
</li>

            
                

<li>
    <a href="#how-are-the-functional-units-are-connected">
        <span>How are the functional units are connected?</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#organisation-of-cache-and-main-memory">
        <span>Organisation of Cache and main memory</span>
    </a>

    
</li>

            
        </ul>
    
</li>

            
                

<li>
    <a href="#arithmetic-logic-units">
        <span>Arithmetic Logic Units</span>
    </a>

    
</li>

            
                

<li>
    <a href="#half-adder-and-full-adder">
        <span>Half Adder and Full Adder</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#half-adder">
        <span>Half Adder</span>
    </a>

    
</li>

            
                

<li>
    <a href="#full-adder">
        <span>Full Adder</span>
    </a>

    
</li>

            
                

<li>
    <a href="#differences">
        <span>Differences</span>
    </a>

    
</li>

            
        </ul>
    
</li>

            
                

<li>
    <a href="#how-control-unit-works">
        <span>How Control Unit works?</span>
    </a>

    
</li>

            
        </ul>
    
</li>

                    
                        

<li>
    <a href="#iii-memory-architecture">
        <span>III. Memory Architecture</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#memory-fundamentals-amp-hardware-lecture-3">
        <span>Memory Fundamentals &amp;amp; Hardware (Lecture 3)</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#1-memory-hierarchy-存储层次结构">
        <span>1. Memory Hierarchy (存储层次结构)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#2-building-blocks-构建模块">
        <span>2. Building Blocks (构建模块)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#3-memory-characteristics-存储特性">
        <span>3. Memory Characteristics (存储特性)</span>
    </a>

    
</li>

            
        </ul>
    
</li>

            
                

<li>
    <a href="#memory-architecture-amp-segments-lecture-4">
        <span>Memory Architecture &amp;amp; Segments (Lecture 4)</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#1-the-platform-amp-memory-map-平台与内存映射">
        <span>1. The Platform &amp;amp; Memory Map (平台与内存映射)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#2-cpu-registers-arm-cortex-m0">
        <span>2. CPU Registers (ARM Cortex-M0+)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#3-memory-segments-内存段">
        <span>3. Memory Segments (内存段)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#4-variable-scope-amp-lifetime-变量作用域与生命周期">
        <span>4. Variable Scope &amp;amp; Lifetime (变量作用域与生命周期)</span>
    </a>

    
</li>

            
        </ul>
    
</li>

            
                

<li>
    <a href="#summary-q-amp-a">
        <span>Summary Q&amp;amp;A</span>
    </a>

    
</li>

            
        </ul>
    
</li>

                    
                        

<li>
    <a href="#iiii-i-o-architecture-and-program-execution">
        <span>IIII. I/O Architecture and Program Execution</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#1-i-o-architecture-输入-输出架构">
        <span>1. I/O Architecture (输入/输出架构)</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#digital-to-analogue-converters-dac-数模转换器">
        <span>Digital to Analogue Converters (DAC, 数模转换器)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#analogue-to-digital-converters-adc-模数转换器">
        <span>Analogue to Digital Converters (ADC, 模数转换器)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#pulse-width-modulation-pwm-脉冲宽度调制">
        <span>Pulse Width Modulation (PWM, 脉冲宽度调制)</span>
    </a>

    
</li>

            
        </ul>
    
</li>

            
                

<li>
    <a href="#2-program-execution-程序执行">
        <span>2. Program Execution (程序执行)</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#the-instruction-cycle-指令周期">
        <span>The Instruction Cycle (指令周期)</span>
    </a>

    
</li>

            
        </ul>
    
</li>

            
                

<li>
    <a href="#summary-q-amp-a">
        <span>Summary Q&amp;amp;A</span>
    </a>

    
</li>

            
        </ul>
    
</li>

                    
                        

<li>
    <a href="#v-embedded-networking-and-communications">
        <span>V. Embedded Networking and Communications</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#1-finite-state-machine-fsm-有限状态机">
        <span>1. Finite State Machine (FSM / 有限状态机)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#2-i-o-operations-输入-输出操作">
        <span>2. I/O Operations (输入/输出操作)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#3-i-o-synchronization-i-o-同步">
        <span>3. I/O Synchronization (I/O 同步)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#4-i-o-access-modes-i-o-访问模式">
        <span>4. I/O Access Modes (I/O 访问模式)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#5-buses-总线">
        <span>5. Buses (总线)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#6-parallel-port-并行端口">
        <span>6. Parallel Port (并行端口)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#7-serial-port-串行端口">
        <span>7. Serial Port (串行端口)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#8-serial-standards">
        <span>8. Serial Standards</span>
    </a>

    
</li>

            
                

<li>
    <a href="#9-board-level-protocols">
        <span>9. Board-Level Protocols</span>
    </a>

    
</li>

            
                

<li>
    <a href="#10-high-level-protocols">
        <span>10. High-Level Protocols</span>
    </a>

    
</li>

            
                

<li>
    <a href="#summary-q-amp-a">
        <span>Summary Q&amp;amp;A</span>
    </a>

    
</li>

            
        </ul>
    
</li>

                    
                        

<li>
    <a href="#vi-real-time-operating-systems-and-scheduling">
        <span>VI. Real Time Operating Systems and Scheduling</span>
    </a>

    
        <ul>
            
                

<li>
    <a href="#1-data-checking-methods-数据校验方法">
        <span>1. Data Checking Methods (数据校验方法)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#2-real-time-operating-systems-rtos-实时操作系统">
        <span>2. Real-Time Operating Systems - RTOS (实时操作系统)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#3-threads-线程">
        <span>3. Threads (线程)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#4-task-states-任务状态">
        <span>4. Task States (任务状态)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#5-real-time-metrics">
        <span>5. Real-Time Metrics</span>
    </a>

    
</li>

            
                

<li>
    <a href="#6-scheduling-algorithms-调度算法">
        <span>6. Scheduling Algorithms (调度算法)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#7-priority-inversion-优先级反转">
        <span>7. Priority Inversion (优先级反转)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#8-multi-core-systems-多核系统">
        <span>8. Multi-Core Systems (多核系统)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#9-network-flow-scheduling-网络流调度">
        <span>9. Network Flow Scheduling (网络流调度)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#10-energy-efficient-scheduling-节能调度">
        <span>10. Energy Efficient Scheduling (节能调度)</span>
    </a>

    
</li>

            
                

<li>
    <a href="#summary-q-amp-a">
        <span>Summary Q&amp;amp;A</span>
    </a>

    
</li>

            
        </ul>
    
</li>

                    
                </ul>
            </div>
        
    </div>
</div>

</body>
</html>
